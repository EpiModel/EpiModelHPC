---
title: "EpiModel for High-Performance Computing"
author: "Samuel M. Jenness"
date: "Department of Epidemiology, University of Washington"
output:
  html_document:
    theme: cerulean
---
<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{EpiModel Introduction}
-->

```{r setup, eval=FALSE, echo=FALSE, message=FALSE}
library(EpiModel.hpc)
```

<br>


## 1. Introduction
The **EpiModel.hpc** package provides high-performance computing (HPC) extensions to the **EpiModel** software (http://epimodel.org). EpiModel supports the simulation of stochastic network models for infectious disease transmission dynamics based on the statistical framework of temporal exponential random graph models (ERGMs). HPC systems may be needed for research-level modeling over networks because ERGM-based model estimation and simulation is computationally intensive in terms of both CPU and memory utilization. 

This tutorial provides background and examples of how to use EpiModel.hpc. This software package was designed to run on MOAB/Torque HPC systems in which there is a job scheduler that uses standard PBS-based shell scripts. Elements of the package may also apply to less complex HPC systems, as the core functionality of this extension package is for MPI-based parallel simulation of models over multiple cores and nodes on an HPC.

The structure of this tutorial is as follows. We first describe 


## 2. A Basic Parallel Simulation

```{r basic1, eval=FALSE}
nw <- network.initialize(n = 1000, directed = FALSE)
formation <- ~ edges
target.stats <- 500
dissolution <- ~ offset(edges)
duration <- 50
coef.diss <- dissolution_coefs(dissolution, duration)

est <- netest(nw, formation, dissolution,
              target.stats, coef.diss)

param <- param.net(inf.prob = 0.25)
init <- init.net(i.num = 50)

control <- control.net(type = "SI", nsteps = 100, verbose = FALSE,
                       par.type = "single", nsims = 4, ncores = 4)

sim <- netsim_parallel(est, param, init, control)
```


## 3. Parallelization with MPI

```{r mpi1, eval=FALSE}
control <- control.net(type = "SI", nsteps = 100, verbose = FALSE,
                       par.type = "mpi", nsims = 25, ncores = 25)

sim <- netsim_parallel(est, param, init, control)
```



## 4. Running Parallel on Torque

Contents of sim001.R file:
```
library(EpiModel.hpc)

nw <- network.initialize(n = 10000, directed = FALSE)
formation <- ~ edges
target.stats <- 5000
dissolution <- ~ offset(edges)
duration <- 50
coef.diss <- dissolution_coefs(dissolution, duration)

est <- netest(nw, formation, dissolution,
              target.stats, coef.diss)

param <- param.net(inf.prob = 0.01)
init <- init.net(i.num = 50)
control <- control.net(type = "SI", nsteps = 1000, verbose = FALSE,
                       par.type = "single", nsims = 16, ncores = 16)
                       
sim <- netsim_parallel(est, param, init, control)

save(sim, file = "sim.rda")
```

Contents of runsim.sh file:
```
#!/bin/bash

### Specs
#PBS -N MyProject
#PBS -l nodes=1:ppn=16,mem=44gb,feature=16core,walltime=06:00:00
#PBS -o <standard output directory>
#PBS -e <standard error directory>
#PBS -d <data directory>
#PBS -m ae
#PBS -M <email address for notifications>


### Modules
module load r_3.1.1

### App
R CMD BATCH --vanilla sim001.R sim001.Rout
```

Running job at the command line:
```
qsub runsim.sh
```


## 5. Checkpointing



## 6. Array Jobs

